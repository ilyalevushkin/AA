\documentclass[a4paper,12pt]{article}

\usepackage[T2A]{fontenc}			
\usepackage[utf8]{inputenc}			
\usepackage[english,russian]{babel}	

\usepackage[
bookmarks=true, colorlinks=true, unicode=true,
urlcolor=black,linkcolor=black, anchorcolor=black,
citecolor=black, menucolor=black, filecolor=black,
]{hyperref}

\usepackage{color}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{black}}
\DeclareCaptionFormat{listing}{\colorbox{white}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 
\usepackage{wasysym}

\usepackage{graphicx}
%\usepackage[cache=false]{minted}
\usepackage{cmap}
\usepackage{indentfirst}

\usepackage{listings} 
\usepackage{fancyvrb}

\usepackage{geometry}
\geometry{left=2cm}
\geometry{right=1.5cm}
\geometry{top=1cm}
\geometry{bottom=2cm}

\setlength{\parindent}{5ex}
\setlength{\parskip}{0.5em}

\begin{document}
\lstset{ %
	language=C++,                 % выбор языка для подсветки (здесь это С)
	basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
	numbers=left,               % где поставить нумерацию строк (слева\справа)
	numberstyle=\tiny,           % размер шрифта для номеров строк
	stepnumber=1,                   % размер шага между двумя номерами строк
	numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
	backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
	showspaces=false,            % показывать или нет пробелы специальными отступами
	showstringspaces=false,      % показывать или нет пробелы в строках
	showtabs=false,             % показывать или нет табуляцию в строках
	frame=single,              % рисовать рамку вокруг кода
	tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
	captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
	breaklines=true,           % автоматически переносить строки (да\нет)
	breakatwhitespace=false, % переносить строки только если есть пробел
	escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
}


% Титульный лист
\large
\begin{center}
	Федеральное государственное бюджетное образовательное учреждение 
	высшего образования <<Московский государственный технический 
	университет имени Н. Э. Баумана>> 
	(национальный исследовательский университет)
\end{center}

\vspace*{30mm} 

\huge
\begin{center}
	Дисциплина: <<Анализ алгоритмов>>
	
	Отчет по лабораторной работе №7
\end{center}

\vspace*{30mm} 

\huge
\begin{center}
	Тема работы:\\
	<<Алгоритмы поиска подстроки в строке>>
\end{center}
\vspace*{30mm} 

\large
\begin{flushright}
	Студент: Левушкин И. К. \\
	Группа: ИУ7-52Б \\
	Преподаватели: Волкова Л. Л., \\ Строганов Ю. В. \\
\end{flushright}

\vspace*{40mm}
\begin{center}
	Москва, 2019 г.  
\end{center}
\thispagestyle{empty}

\tableofcontents
% \setcounter{page}{1}

\section*{Введение}
\addcontentsline{toc}{section}{Введение}

\textbf{Поиск подстроки в строке} --- важная задача поиска информации.
Применяется в виде встроенной функции в текстовых редакторах, СУБД,
поисковых машинах и языках программирования.

Такой поиск приходится проводить довольно часто, поэтому необходимо, чтобы
он осуществлялся как можно быстрее. Становится ясно, что наивный алгоритм с
полным перебором всех частей строки, длины которых соответствуют
длине шаблона, является не самым эффективным способом решения такой задачи.

Существует немалое количество алгоритмов, справляющихся с поиском подстроки,
лучше, чем примитивный перебор. Особенно красиво реализуются
алгоритмы, основанные на применении конечных автоматов.

\textbf{Цель лабораторной работы:} изучение метода динамического программирования
на материале алгоритмов поиска подстроки в строке.

\textbf{Задачи работы:}

\begin{enumerate} 
	\item[1)] изучить алгоритмы поиска подстроки в строке Кнута-Морриса-Пратта
	и Бойера-Мура;
	\item[2)] применить метод динамического программирования для  
	реализации указанных алгоритмов;
	\item[3)] провести сравнительный анализ алгоритмов по времени выполнения;
	\item[4)] экспериментально подтвердить различия во временнóй эффективности алгоритмов 
	при помощи разработанного программного обеспечения на материале замеров процессорного 
	времени на строках различных размеров;
	\item[5)] описать и обосновать полученные результаты в отчете о лабораторной 
	работе, выполненного как расчётно-пояснительная записка. 
\end{enumerate} 
\pagebreak

\section{Аналитический раздел}

В данном разделе будут рассмотрены выбранные алгоритмы поиска подстроки в строке.

\subsection{Описание алгоритмов}

\subsubsection{Алгоритм Кнута-Морриса-Пратта}

Алгоритм Кнута-Морриса-Пратта основан на принципе конечного автомата.
В этом алгоритме состояния помечаются символами, совпадение с которыми должно в данный момент произойти.
Из каждого состояния имеется два перехода: один соответствует успешному сравнению, другой — несовпадению.
Успешное сравнение переводит нас в следующий узел автомата, а в случае несовпадения мы попадаем
в предыдущий узел, отвечающий образцу.
Пример автомата Кнута-Морриса-Пратта для подстроки \textit{ababcb} приведен на рис. \ref{fig:kmp_example}. ~\cite{mcconell}

\begin{figure}[h!]
	\begin{center}
		{\includegraphics[scale = 0.5]{kmp_example.png}}
		\caption{
			Полный автомат Кнута-Морриса-Пратта для подстроки \textit{ababcb}}
		\label{fig:kmp_example}
	\end{center}
\end{figure}

При всяком переходе по успешному сравнению в конечном автомате
Кнута-Морриса-Пратта происходит выборка нового символа из текста.
Переходы, отвечающие неудачному сравнению, не приводят к выборке нового символа;
вместо этого они повторно используют последний выбранный символ. Если мы перешли в конечное состояние,
то это означает, что искомая подстрока найдена.

\subsubsection{Алгоритм Бойера-Мура}

Алгоритм Бойера-Мура осуществляет сравнение с образцом справа налево,
а не слева направо, как алгоритм Кнута-Морриса-Пратта.
Исследуя искомый образец, можно осуществлять более эффективные прыжки в тексте при обнаружении несовпадения ~\cite{mcconell}.

Рассмотрим строку \textit{there they are} и подстроку \textit{they}.
Здесь сначала сравнивается \textit{y} с \textit{r} и обнаруживается несовпадение.
Поскольку известно, что буква \textit{r} вообще не входит в образец,
можно сдвинуться в тексте на целых четыре буквы (т. е. на длину образца)
вправо. Затем сравнивается буква \textit{y} с \textit{h} и вновь обнаруживается
несовпадение. Однако поскольку на этот раз \textit{р} входит в образец,
есть возможность сдвинуться вправо только на две буквы так, чтобы буквы
\textit{h} совпали.
Затем начинается сравнение справа и обнаруживается полное совпадение кусочка текста с 
образцом. В алгоритме Бойера—Мура делается 6
сравнений вместо 13 сравнений в примитивном алгоритме, в котором
рассматриваются все подстроки исходной строки, совпадающие по длине
с шаблоном.

Пример проиллюстрирован в таблице \ref{bm_example}.

\begin{table} [h!]
	\begin{center}
		\caption{Поиск образца they в тексте \textit{there they are}}
		\begin{tabular}{r|rrrrrrrrrrrrrr|}
			
			&          t &          h &          e &          r &          e &            &          t &          h &          e &          y &            &          a &          r &          e \\
			
			1 &          t &          h &          e &          y &            &            &            &            &            &            &            &            &            &            \\
			
			2 &            &            &            &            &          t &          h &          e &          y &            &            &            &            &            &            \\
			
			3 &            &            &            &            &            &            &          t &          h &          e &          y &            &            &            &            \\
			
		\end{tabular}
		
		\label{bm_example}
	\end{center}
\end{table} 

Алгоритм Бойера-Мура обрабатывает образец двумя способами.
Во-первых, можно вычислить величину возможного сдвига при несовпадении
очередного символа.
Во-вторых, вычисляется величина
прыжка. Эти действия помогают эффективно подстраивать шаблон под новую подстроку.

\subsection*{Выводы}
\addcontentsline{toc}{subsection}{Выводы}

Рассмотрены алгоритмы поиска подстроки в строке,
предоставляющие, очевидно, более эффективное решение в сравнении с наивным алгоритмом.
Обоснованы различия между приведенными алгоритмами и выделены ключевые моменты
каждого из них.

\section{Конструкторский раздел}

В разделе приводятся схемы выбранных алгоритмов поиска подстроки в строке,
производится их теоретический сравнительный анализ.

\subsection{Разработка алгоритмов}

На рис. \ref{fig:shift}-\ref{fig:bm} приведены схемы 
алгоритмов поиска подстроки.

\begin{figure}[h!]
	\begin{center}
		{\includegraphics[scale = 0.4]{shift.pdf}}
		\caption{
			Заполнение массива сдвигов}
		\label{fig:shift}
	\end{center}
\end{figure}

\pagebreak

\begin{figure}[h!]
	\begin{center}
		{\includegraphics[scale = 0.4]{kmp.pdf}}
		\caption{
			Алгоритм Кнута-Морриса-Пратта}
		\label{fig:kmp}
	\end{center}
\end{figure}

\pagebreak

\begin{figure}[h!]
	\begin{center}
		{\includegraphics[scale = 0.35]{bm.pdf}}
		\caption{
			Алгоритм Бойера-Мура}
		\label{fig:bm}
	\end{center}
\end{figure}

\pagebreak

\subsection{Сравнительный анализ алгоритмов}
\label{fig:cmp_section}

\subsubsection{Пример работы алгоритма Кнута-Морриса-Пратта}

Рассмотрим пример работы алгоритмов на
строке \textit{ababqcabababakababacqw} длиной 22 символа
и подстроке \textit{ababac} длиной 6 символов.

Сперва необходимо построить префикс-функцию для подстроки. Для этого
последовательно пройдем по подстроке в поисках очередного максимального суффикса,
равного префиксу. Пошаговый разбор представлен в таблице \ref{pref}:
слева отмечен индекс нового входящего символа, посередине ---
рассматриваемая строка, справа --- значение префикс-функции.
\textit{Курсивом} и \textbf{жирным} выделены совпадающие максимальные
\textit{префиксы} и \textbf{суффиксы}.

\begin{table} [h!]
	\begin{center}
		\caption{Нахождение префикс-функции}
		\begin{tabular}{|r|rrrrrr|r|}
			\hline
			Индекс & Строка & & & & & & Префикс-функция \\
			\hline
			0 &          a &            &            &            &            &            &          0 \\
			
			1 &          a &          b &            &            &            &            &          0 \\
			
			2 &    {\it a} &          b &    {\bf a} &            &            &            &          1 \\
			
			3 &    {\it a} &    {\it b} &    {\bf a} &    {\bf b} &            &            &          2 \\
			
			4 &    {\it a} &    {\it b} & {\itshape \bf a} &    {\bf b} &    {\bf a} &            &          3 \\
			
			5 &          a &          b &          a &          b &          a &          c &          0 \\
			\hline
		\end{tabular}
		\label{pref}
	\end{center}
\end{table}  

Далее уже применим похожий подход для поиска подстроки.
При несовпадении символов, будем смещать подстроку таким образом, чтобы 
префикс строки (до нового рассматриваемого символа этой строки) был равен
некоторому префиксу подстроки (табл. \ref{kmp_cmp}).

\begin{table} [h!]
	\begin{center}
		\caption{Пример работы алгоритма Кнута-Морриса-Пратта}
		\begin{tabular}{|rrrrrrrrrrrrrrrrrrrrrrr|}
			\hline
			&          0 &          1 &          2 &          3 &          4 &          5 &          6 &          7 &          8 &          9 &         10 &         11 &         12 &         13 &         14 &         15 &         16 &         17 &         18 &         19 &         20 &         21 \\
			
			&          a &          b &          a &          b &    {\bf q} &    {\bf c} &          a &          b &          a &          b &          a &    {\bf b} &          a &    {\bf k} &          a &          b &          a &          b &          a &          c &          q &          w \\
			
			1 &    {\bf a} &    {\bf b} &    {\bf a} &    {\bf b} &    {\bf a} &          c &            &            &            &            &            &            &            &            &            &            &            &            &            &            &            &            \\
			
			2 &            &            &            &            &            &    {\bf a} &          b &          a &          b &          a &          c &            &            &            &            &            &            &            &            &            &            &            \\
			
			3 &            &            &            &            &            &            &    {\bf a} &    {\bf b} &    {\bf a} &    {\bf b} &    {\bf a} &    {\bf c} &            &            &            &            &            &            &            &            &            &            \\
			
			4 &            &            &            &            &            &            &            &            &    {\bf a} &    {\bf b} &    {\bf a} &    {\bf b} &    {\bf a} &    {\bf c} &            &            &            &            &            &            &            &            \\
			
			5 &            &            &            &            &            &            &            &            &            &            &            &            &            &            &    {\bf a} &    {\bf b} &    {\bf a} &    {\bf b} &    {\bf a} &    {\bf c} &            &            \\
			\hline
		\end{tabular}  
		\label{kmp_cmp}
	\end{center}
\end{table}

\begin{itemize}
	\item[1)] несовпадение происходит на символе с индексом 4,
	подходящего префикса нет, поэтому следующее сравнение начинаем с 5 символа;
	\item[2)] аналогичная ситуация;
	\item[3)] несовпадение на 11 символе, суффикс \textit{abab}
	равен префиксу подстроки, значение префикс-функции для данной части подстроки
	равно 2, поэтому имеем соответствующее смещение;
	\item[4)] аналогичный случай в 1-2 этапах;
	\item[5)] полное совпадение.
\end{itemize}

Для нахождения потребовалось 5 сравнений на первом этапе, 1 --- на втором,
по 6 --- на остальных этапах. Итого, 24 сравнения. В наивном алгоритме
потребовалось бы 38 сравнений.

\subsubsection{Пример работы алгоритма Бойера-Мура}

Посмотрим, как работает алгоритм Бойера-Мура на тех же входных данных.

В алгоритме Бойера-Мура необходимо дополнительно найти
массив стоп-символов и массив сдвигов.
Длина массива стоп-символов равна мощности алфавита, над которым производятся действия.
Для каждого уникального символа подстроки вычислим индекс самого последнего вхождения
и занесем его в этот массив, для остальных символов поставим значение равное -1.
Итак, для \textit{a} -- 4, \textit{b} -- 3, \textit{c} -- 5.

Для каждого возможного суффикса шаблона указываем наименьшую величину,
на которую нужно сдвинуть вправо шаблон,
чтобы он снова совпал с префиксом и при этом символ,
предшествующий этому вхождению, не совпадал бы с символом, предшествующим суффиксу.
Если такой сдвиг невозможен, ставится длина подстроки (табл. \ref{shift_}).

\begin{table} [h!]
	\begin{center}
		\caption{Массив сдвигов в алгоритме Бойера-Мура}
		\begin{tabular}{|r|rrrrrr|}
			\hline
			Индекс & 0 &          1 &          2 &          3 &          4 &          5 \\
			\hline
			Строка &         a &          b &          a &          b &          a &          c \\
			\hline
			Сдвиг &         6 &          2 &          3 &          4 &          5 &          6 \\
			\hline
		\end{tabular}  
		\label{shift_}
	\end{center}
\end{table}

Теперь можно перейти непосредственно к поиску подстроки (табл. \ref{bm_cmp}).

\begin{table} [h!]
	\begin{center}
		\caption{Пример работы алгоритма Бойера-Мура}
		\begin{tabular}{|rrrrrrrrrrrrrrrrrrrrrrr|}
			\hline
			&          0 &          1 &          2 &          3 &          4 &          5 &          6 &          7 &          8 &          9 &         10 &         11 &         12 &         13 &         14 &         15 &         16 &         17 &         18 &         19 &         20 &         21 \\
			
			&          a &          b &          a &          b &    {\bf q} &          c &          a &    {\bf b} &          a &    {\bf b} &          a &    {\bf b} &          a &    {\bf k} &          a &          b &          a &          b &          a &          c &          q &          w \\
			
			1 &          a &          b &          a &          b &    {\bf a} &    {\bf c} &            &            &            &            &            &            &            &            &            &            &            &            &            &            &            &            \\
			
			2 &            &            &          a &          b &          a &          b &          a &    {\bf c} &            &            &            &            &            &            &            &            &            &            &            &            &            &            \\
			
			3 &            &            &            &            &          a &          b &          a &          b &          a &    {\bf c} &            &            &            &            &            &            &            &            &            &            &            &            \\
			
			4 &            &            &            &            &            &            &          a &          b &          a &          b &          a &    {\bf c} &            &            &            &            &            &            &            &            &            &            \\
			
			5 &            &            &            &            &            &            &            &            &          a &          b &          a &          b &          a &    {\bf c} &            &            &            &            &            &            &            &            \\
			
			6 &            &            &            &            &            &            &            &            &            &            &            &            &            &            &    {\bf a} &    {\bf b} &    {\bf a} &    {\bf b} &    {\bf a} &    {\bf c} &            &            \\
			\hline
		\end{tabular}  
		\label{bm_cmp}
	\end{center}
\end{table}

\begin{itemize}
	\item[1)] несовпадение происходит на символе с индексом 4,
	префикс \textit{ab} совпадает с суффиксом, поэтому смещаемся на 2
	в соответствии с массивом сдвигов;
	\item[2-5)] аналогичная ситуация несовпадения,
	только смещение происходит по стоп-таблице, так как нет подходящего суффикса;
	\item[6)] полное совпадение.
\end{itemize}

Для нахождения потребовалось 2 сравнения на первом этапе,
4 --- на последнем этапе, по 1 --- на всех остальных. Всего 12 сравнений.

\subsubsection{Оценка времени работы алгоритма Кнута-Морриса-Пратта}

Рассмотрим сравнение строк на позиции
$i$, где образец $S[0, m - 1]$
сопоставляется с частью текста
$T[i, i + m - 1]$.
Предположим, что первое несовпадение произошло
между $T[i + j]$ и $S[j]$,
где $1 < j < m$. Тогда
$T[i, i + j - 1] = S[0, j - 1] = P$ и
$a = T[i + j] \neq S[j] = b$.

При сдвиге вполне можно ожидать, что префикс 
(начальные символы)
образца $S$ сойдется с каким-нибудь суффиксом 
(конечные символы) текста $P$. Длина наиболее 
длинного префикса, являющегося одновременно 
суффиксом, есть значение префикс-функции от строки 
$S$ для 
индекса $j$.

Это приводит нас к следующему алгоритму: пусть
$\pi[j]$ -- значение префикс-функции от 
строки $S[0, m - 1]$ для индекса $j$. 
Тогда после сдвига мы можем возобновить сравнения с 
места $T[i + j]$ и $S[\pi[j]]$ без потери возможного 
местонахождения образца. Можно показать, 
что таблица 
$\pi$ может быть вычислена (амортизационно) 
за $\mathbf{O(m)}$ сравнений перед 
началом поиска. А поскольку строка $T$ будет 
пройдена 
ровно один раз, суммарное время работы алгоритма 
будет равно $\mathbf{O(m + n)}$, где $n$ -- длина 
текста $T$. ~\cite{knuth}

\subsubsection{Оценка времени работы алгоритма Бойера-Мура}

Ниже мы обозначаем через $\mathbf{A}$ — число символов в алфавите.

При подсчете массива сдвигов по одному присваиванию приходится
на каждый элемент массива и еще по одному -- на каждый символ
образца. Поэтому общее число присваиваний равно $\mathbf{O(m + A)}$.
При вычислении массива прыжков в худшем случае каждый символ
образца будет сравниваться со всеми последующими его символами.

Можно подсчитать, что число сравнений в худшем случае
будет $\mathbf{O(mn)}$. В лучшем случае асимптотика равна $\mathbf{O(m + n)}$.
~\cite{eng_bm}


\subsection*{Выводы}
\addcontentsline{toc}{subsection}{Выводы}

В разделе представлены схемы алгоритмов поиска подстроки в строке
Кнута-Морриса-Пратта и Бойера-Мура.
Произведен теоретический анализ
временной сложности, обозначены различия в работе алгоритмов,
пояснена их эффективность.

\section{Технологический раздел}

Здесь описываются требования к программному 
обеспечению и средства реализации, приводятся листинги 
программы и тестовые данные.

\subsection{Требования к программному обеспечению}

\begin{flushleft}
	\textbf{Входные данные:} 
	\begin{itemize}
		\item \textit{text} --- строка, в которой ведется поиск;
		\item \textit{pattern} --- искомая подстрока.
	\end{itemize}
	
	\textbf{Выходные данные:} индекс первого вхождения
	подстроки \textit{pattern} в строке
	\textit{text}; при отсутствии подстроки либо неверных данных
	(длина подстроки превышает длину строки) --- сообщение об этом.
\end{flushleft}

\subsection{Средства реализации}

Программа написана на языке Python ~\cite{python}, который 
предоставляет программисту мощные инструменты для реализации различных алгоритмов и является достаточно 
надежным, эффективным и удобным для реализации сложных алгоритмов. Для написания использовался 
редактор исходного кода \textit{PyCharm} ~\cite{pycharm}.

Замер времени выполнения программы 
производится с помощью функции \textit{process\_time()} из библиотеки \textit{time},
функционал которой позволяет подсчитывать процессорное время в тиках,
а затем конвертировать полученный результат в секунды.

\subsection{Листинг программы}

Реализованная программа представлена
в листингах \ref{lst0}, \ref{lst1} и \ref{lst2}.

\begin{lstlisting}[label=lst0,caption=Реализация
заполнения массива сдвигов]
def get_fail(substring):
	fail = [0 for i in range(len(substring))]
	fail[0] = -1
	for i in range(1, len(substring)):
		temp = fail[i - 1]
		while ((substring[temp] != substring[i - 1]) and (temp > -1)):
			temp = fail[temp]
		fail[i] = temp + 1
	return fail
\end{lstlisting}

\begin{lstlisting}[label=lst1,caption=Реализация
алгоритма Кнута-Морриса-Пратта]
def knut_moris_prat(text, substring):
	subLoc = 0
	textLoc = 0
	
	fail = get_fail(substring)
	
	while (textLoc < len(text) and subLoc < len(substring)):
		if (subLoc == -1 or text[textLoc] == substring[subLoc]):
			textLoc += 1
			subLoc += 1
		else:
			subLoc = fail[subLoc]
	
	if (subLoc > len(substring) - 1):
		return textLoc - len(substring)
	else:
		return -1
\end{lstlisting}

\begin{lstlisting}[label=lst2,caption=Реализация
алгоритма Бойера-Мура]
def create_dict(pattern):
	d = {}
	len_pattern = len(pattern)
	for i in pattern:
		if (d.get(i) is None):
			d.update({i : len_pattern})
	
	return d
	
	
def get_slide_mas(pattern):
	slide = create_dict(pattern)
	
	len_pattern = len(pattern)
	
	for i in range(len(pattern)):
		slide.update({pattern[i] : len_pattern - i - 1})
	
	slide.update({pattern[len(pattern) - 1] : len_pattern})
	
	return slide


def get_jump_mas(pattern):
	
	jump = [0 for i in range(len(pattern))]
	
	for i in range(len(pattern)):
		jump[i] = 2 * len(pattern) - i - 1
	
	test = len(pattern) - 1
	target = len(pattern)
	
	link = [0 for i in range(len(pattern))]
	
	while (test > -1):
		link[test] = target
		while (target < len(pattern) and (pattern[test] != pattern[target])):
			jump[target] = min(jump[target], len(pattern) - 1 - test)
			target = link[target]
		test -= 1
		target -= 1
	
	for i in range(target + 1):
		jump[i] = min(jump[i], len(pattern) + target - i)
	
	temp = link[target]
	while (target < len(pattern) - 1):
		while (target <= temp):
			jump[target] = min(jump[target], temp - target + len(pattern))
			target += 1
		temp = link[temp]
	
	return jump


def boyer_mur(text, pattern):
	textLoc = len(pattern) - 1
	patternLoc = len(pattern) - 1
	
	slide = get_slide_mas(pattern)
	jump = get_jump_mas(pattern)
	
	while (textLoc < len(text) and (patternLoc > -1)):
		if (text[textLoc] == pattern[patternLoc]):
			textLoc -= 1
			patternLoc -= 1
		else:
			if (slide.get(text[textLoc]) is None):
				textLoc += max(len(pattern), jump[patternLoc])
			else:
				textLoc += max(slide.get(text[textLoc]), jump[patternLoc])
			patternLoc = len(pattern) - 1
	
	if (patternLoc == -1):
		return textLoc + 1
	else:
		return -1
\end{lstlisting}

\subsection{Тестовые данные}
\label{fig:test_data}

Для тестирования выделены следующие случаи, представленные в табл. \ref{test0}.

\begin{table} [h!]
	\begin{center}
		\caption{Тестовые данные}
		\begin{tabular}{|r|r|r|r|}
			\hline
			№ &     Строка &  Подстрока &  Результат \\
			\hline
			1 &          a &        abc &  Неверная длина \\
			\hline
			2 &        abc &       abcd &  Неверная длина \\
			\hline
			3 &        abc &        def &  Не найдено \\
			\hline
			4 &        abc &         aa &  Не найдено \\
			\hline
			5 &  abbaabbab &       aaab &  Не найдено \\
			\hline
			6 &        abc &          a &          0 \\
			\hline
			7 &  abbaabbab &       abba &          0 \\
			\hline
			8 &        abc &          b &          1 \\
			\hline
			9 &  abbaabbab &       baab &          2 \\
			\hline
			10 & there they are &       they &          6 \\
			\hline
			11 &        abc &          c &          2 \\
			\hline
			12 &  abbaabbab &       bbab &          5 \\
			\hline
			13 & there they are &        are &         11 \\
			\hline
			14 &     abcabc &          a &          0 \\
			\hline
			15 &     abcabc &          c &          2 \\
			\hline
			16 & abbaabbabbbab &       bbab &          5 \\
			\hline
			17 & there they are are here are &        are &         11 \\
			\hline
			18 &          a &          a &          0 \\
			\hline
			19 &        abc &        abc &          0 \\
			\hline
			20 & abbaabbabbbab & abbaabbabbbab &          0 \\
			\hline
		\end{tabular} 
		
		\label{test0}
	\end{center}
\end{table}

\subsection*{Выводы}
\addcontentsline{toc}{subsection}{Выводы}

В данном разделе были рассмотрены требования к 
программному обеспечению, обоснован выбор средств 
реализации, приведены листинги программы и тестовые 
данные.

\newpage

\section{Исследовательский раздел}

В разделе представлены примеры выполнения программы,
а также результаты исследования эффективности сортировок.

\subsection{Примеры работы}

На рис. \ref{fig:t0}-\ref{fig:t6} приведены примеры работы программы. 

\begin{figure}[h!]
	\center{\includegraphics[scale = 0.65]{0.jpg}}
	\caption{
		Некорректная длина}
	\label{fig:t0}
\end{figure}

\begin{figure}[h!]
	\center{\includegraphics[scale = 0.65]{1.jpg}}
	\caption{
		Подстрока не найдена}
	\label{fig:t1}
\end{figure}

\begin{figure}[h!]
	\center{\includegraphics[scale = 0.65]{2.jpg}}
	\caption{
		Подстрока в начале}
	\label{fig:t2}
\end{figure}

\pagebreak

\begin{figure}[h!]
	\center{\includegraphics[scale = 0.6]{3.jpg}}
	\caption{
		Подстрока в середине}
	\label{fig:t3}
\end{figure}

\begin{figure}[h!]
	\center{\includegraphics[scale = 0.5]{4.jpg}}
	\caption{
		Подстрока в конце}
	\label{fig:t4}
\end{figure}

\begin{figure}[h!]
	\center{\includegraphics[scale = 0.6]{5.jpg}}
	\caption{
		Повтор подстроки}
	\label{fig:t5}
\end{figure}

\begin{figure}[h!]
	\center{\includegraphics[scale = 0.6]{6.jpg}}
	\caption{
		Строка равна подстроке}
	\label{fig:t6}
\end{figure}


\pagebreak


Необходимо cравнить время работы реализованных алгоритмов
поиска подстроки в строке. Размер строки меняется от 100 тыс.
до 1 млн. символов, длина шаблона -- 100.
Строка содержит только символы \textit{a},
в подстроке символы \textit{b} и \textit{a}
чередуются (реализуется худший случай для
алгоритма Бойера-Мура).

\subsection{Сравнительный анализ на основе эксперимента}

Замеры произведены на 4-ядерном процессоре \textit{Intel Core i7}
с тактовой частотой 2,4 ГГц, оперативная память --- 8 ГБ.

На рис. \ref{fig:chart_substr} приводятся графики сравнения времени выполнения выбранных алгоритмов.

\begin{figure}[h!]
	\center{
		\includegraphics[width = \textwidth]{chart_substr.pdf}}
	\caption{Сравнение времени выполнения алгоритмов поиска подстроки в строке}
	\label{fig:chart_substr}
\end{figure}

Как видно, подтверждены теоретические расчеты. В худшем случае
асимптотика алгоритма Бойера-Мура квадратична, а Кнута-Морриса-Пратта -- линейна.
Из-за того, что все символы \textit{a} из текста повторяются в шаблоне $m$ раз, эвристика хорошего суффикса будет пытаться сопоставить шаблон в каждой позиции (суммарно, $n$ раз), а эвристика плохого символа в каждой позиции будет двигать строку $m$ раз. Итого, $\mathbf{O(mn)}$ ~\cite{search}.

\subsection*{Выводы}
\addcontentsline{toc}{subsection}{Выводы}

Программа успешно прошла все заявленные тесты. Эксперименты замера времени подтвердили предположения и
теоретические расчеты из раздела \ref{fig:cmp_section}.

\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}

В ходе работы выполнено следующее:

\begin{enumerate} 
	\item[1)] изучены алгоритмы поиска подстроки в строке;
	\item[2)] применен метод динамического программирования для  
	реализации указанных алгоритмов;
	\item[3)] проведен сравнительный анализ алгоритмов по времени выполнения;
	\item[4)] экспериментально подтверждены различия во временнóй эффективности алгоритмов 
	при помощи разработанного программного обеспечения на материале замеров процессорного 
	времени на строках различных размеров;
	\item[5)] описаны и обоснованы полученные результаты в отчете о лабораторной 
	работе, выполненного как расчётно-пояснительная записка. 
\end{enumerate}

\addcontentsline{toc}{section}{Список литературы}
\begin{thebibliography}{8}
	
	\bibitem{mcconell}
	Дж. Макконнелл. Анализ алгоритмов. Активный 
	обучающий 
	подход.-М.:Техносфера, 2009.
	
	\bibitem{knuth}
	Д. Кнут. Искусство программирования, М., Мир, 1978
	
	\bibitem{search}
	Алгоритмы поиска в строке [Электронный ресурс]. – Режим доступа: https://habr.com/ru/post/111449//, свободный – (26.11.2019)
	
	\bibitem{kmp_}
	Поиск подстроки. Алгоритм Кнута–Морриса-Пратта [Электронный ресурс]. – Режим доступа: https://habr.com/ru/post/191454/, свободный – (21.11.2019)
	
	\bibitem{bminfo}
	Алгоритм Бойера-Мура для поиска по шаблону [Электронный ресурс]. – Режим доступа: http://espressocode.top/boyer-moore-algorithm-for-pattern-searching/, свободный – (26.11.2019)
	
	\bibitem{eng_bm}
	Алгоритм Бойера-Мура для поиска по шаблону [Электронный ресурс]. – Режим доступа: http://www-igm.univ-mlv.fr/~lecroq/string/node14.html, свободный – (26.11.2019)
	
	\bibitem{std}
	ISO/IEC 14882:2017 [Электронный ресурс]. – Режим доступа: https://www.iso.org/standard/68564.html, свободный – (27.11.2019)
	
	\bibitem{chrono}
	<chrono> [Электронный ресурс]. – Режим доступа: http://www.cplusplus.com/reference/chrono/, свободный – (20.11.2019)
	
	\bibitem{python}
	Python 3.8.2rc1 documentation [Электронный ресурс]. - Режим доступа: https://docs.python.org/3/, свободный - (28.11.2019)
	
	\bibitem{pycharm}
	PyCharm documentation [Электронный ресурс]. - Режим доступа: https://www.jetbrains.com/pycharm/documentation/ - (28.11.2019)
	
\end{thebibliography}

\end{document}